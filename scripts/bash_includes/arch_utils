#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-2-Clause

ARCH_VARS_LIST=()
ARCH_VARS_LIST+=(SHORT)
ARCH_VARS_LIST+=(FAMILY)
ARCH_VARS_LIST+=(ELF_NAME)
ARCH_VARS_LIST+=(LD_OUTPUT)
ARCH_VARS_LIST+=(EFI)
ARCH_VARS_LIST+=(GCC_TC)
ARCH_VARS_LIST+=(GCC_FLAGS)
ARCH_VARS_LIST+=(GCC_TC_CODENAME)


i386_ARCH_SHORT="x86"
i386_ARCH_FAMILY="generic_x86"
i386_ARCH_ELF_NAME="elf32-i386"
i386_ARCH_LD_OUTPUT="elf_i386"
i386_ARCH_EFI="ia32"
i386_ARCH_GCC_TC="i686"
i386_ARCH_GCC_FLAGS="-m32 -march=i686"
i386_ARCH_GCC_TC_CODENAME="x86-i686"

x86_64_ARCH_SHORT="x86_64"
x86_64_ARCH_FAMILY="generic_x86"
x86_64_ARCH_ELF_NAME="elf64-x86-64"
x86_64_ARCH_LD_OUTPUT="elf_x86_64"
x86_64_ARCH_EFI="x86_64"
x86_64_ARCH_GCC_TC="x86_64"
x86_64_ARCH_GCC_FLAGS="-m64"
x86_64_ARCH_GCC_TC_CODENAME="x86-64-core-i7"

riscv64_ARCH_SHORT="riscv64"
riscv64_ARCH_FAMILY="riscv"
riscv64_ARCH_ELF_NAME="elf64-littleriscv"
riscv64_ARCH_LD_OUTPUT="elf64lriscv"
riscv64_ARCH_GCC_TC="riscv64"
riscv64_ARCH_GCC_FLAGS=""
riscv64_ARCH_GCC_TC_CODENAME="riscv64-lp64d"


function set_arch_gcc_tc_arch {

   local name="${1}_ARCH_GCC_TC"
   local value=${!name}

   if [[ "$value" == "" ]]; then
      echo "ERROR: TARGET arch '$1' is NOT supported."
      exit 1
   fi

   ARCH_GCC_TC=$value
}

function set_host_arch_variable {

   HOST_ARCH="`uname -m`"

   if [[ "$HOST_ARCH" == "x86_64" ]]; then

      : # Great, that's what we expect: do nothing

   elif [[ "$HOST_ARCH" == "amd64" ]]; then

      # An alias for x86_64: fix our variable
      HOST_ARCH="x86_64"

   elif [[ "$HOST_ARCH" == "i686" ]]; then

      # Special case, not "officially" supported.
      # We need to set HOST_ARCH to "i386", to match the convention
      # used by ARCH and ld.

      HOST_ARCH="i386"

   elif [[ "$HOST_ARCH" == "aarch64" ]]; then


      if [[ "$USE_CUSTOM_GCC_TC" != 1 ]]; then
         echo "ERROR: set USE_CUSTOM_GCC_TC=1 to build on $HOST_ARCH"
         exit 1
      fi

   else

      echo "ERROR: build host architecture $HOST_ARCH not supported"
      exit 1
   fi
}

function set_gcc_tc_defaults {

   # Default GCC toolchain version to use. Unfortunately, it depends on the
   # target # architecture, because the list of available pre-built toolchains
   # on https://toolchains.bootlin.com depends on the architecture.

   if ! [ -f $GCC_TC_CONF/$ARCH/default_ver ]; then
      echo "ERROR: file $GCC_TC_CONF/$ARCH/default_ver not found"
      exit 1
   fi

   DEFAULT_GCC_TC_VERSION=$(cat $GCC_TC_CONF/$ARCH/default_ver)
   MIN_GCC_TC_VERSION=$(cat $GCC_TC_CONF/$ARCH/min_ver)

   # Custom GCC toolchain from https://github.com/vvaltchev/musl-cross-make
   # TODO: add a per-arch configuration file for this toolchain as well.
   CUSTOM_GCC_TC_VERSION="11.4.0"
}

function set_gcc_ver {

   if [[ "$GCC_TC_VER" == "" ]]; then

      if [ -f $TC/.gcc_tc_ver_$ARCH ]; then

         GCC_TC_VER=$(cat $TC/.gcc_tc_ver_$ARCH)

      else

         # GCC_TC_VER is not defined and there is no .gcc_tc_ver_$ARCH file.

         if [[ "$USE_CUSTOM_GCC_TC" == 1 ]]; then
            GCC_TC_VER=$CUSTOM_GCC_TC_VERSION    # Custom GCC toolchain
         elif [[ "$HOST_ARCH" == "$BUILD_ARCH" ]]; then
            GCC_TC_VER="$DEFAULT_GCC_TC_VERSION" # Main case, fully supported
         fi
      fi
   fi

   if [[ "$GCC_TC_VER" == "" ]]; then
      echo "ERROR: GCC_TC_VER is not set"
      exit 1
   fi
}

function set_arch_variables {

   for v in ${ARCH_VARS_LIST[@]}; do
      local name=${ARCH}_ARCH_${v}
      local value=${!name}
      eval "ARCH_${v}='$value'"
   done
}

#
# If $ARCH_GCC_TC_VER has not been set externally or by the check above,
# we'll use the pre-built bootlin toolchains, which do not use the GCC
# version in their name, but a year/month combination with additional
# fields. Therefore, let's map our desired GCC version to the bootlin
# toolchain name.
#
function set_arch_gcc_tc_ver {

   if [[ "$ARCH_GCC_TC_VER" != "" ]]; then
      # ARCH_GCC_TC_VER has been set either externally or to "custom"
      # in case USE_CUSTOM_GCC_TC was set.
      return
   fi

   case $1 in
      6.4.0) ARCH_GCC_TC_VER="stable-2018.02-2"; ARCH_GCC_TC_EXT="tar.bz2";;
      7.3.0) ARCH_GCC_TC_VER="stable-2018.11-1"; ARCH_GCC_TC_EXT="tar.bz2";;
      8.4.0) ARCH_GCC_TC_VER="stable-2020.02-2"; ARCH_GCC_TC_EXT="tar.bz2";;
      9.3.0) ARCH_GCC_TC_VER="stable-2020.08-1"; ARCH_GCC_TC_EXT="tar.bz2";;
      10.3.0) ARCH_GCC_TC_VER="stable-2021.11-1"; ARCH_GCC_TC_EXT="tar.bz2";;
      11.3.0) ARCH_GCC_TC_VER="stable-2022.08-1"; ARCH_GCC_TC_EXT="tar.bz2";;
      12.3.0) ARCH_GCC_TC_VER="stable-2024.02-1"; ARCH_GCC_TC_EXT="tar.bz2";;
      13.3.0) ARCH_GCC_TC_VER="stable-2024.05-1"; ARCH_GCC_TC_EXT="tar.xz";;
      *) echo "ERROR: unknown ARCH_GCC_TC_VER for GCC $GCC_TC_VER"; exit 1;;
   esac
}

function save_and_check_gcc_tc_ver {

   if ! [ -f $TC/.gcc_tc_ver_$ARCH ]; then

      mkdir -p $TC
      echo -n $GCC_TC_VER > $TC/.gcc_tc_ver_$ARCH

   else

      saved=$(cat $TC/.gcc_tc_ver_$ARCH)
      v=$GCC_TC_VER

      if ! [ "$GCC_TC_VER" = "$saved" ]; then
         echo "ERROR: GCC_TC_VER ($v) does not match with saved one ($saved)"
         echo "ERROR: This is NOT a supported scenario. Please delete:"
         echo "   $TC/$ARCH"
         echo "   $TC/.gcc_tc_ver_$ARCH"
         echo "And run this script again to use the new toolchain."
         exit 1
      fi
   fi
}

function dump_build_toolchain_env {

   echo
   echo "ARCH=$ARCH"
   echo "HOST_ARCH=$HOST_ARCH"
   echo "USE_CUSTOM_GCC_TC=$USE_CUSTOM_GCC_TC"
   echo "GCC_TC_VER=$GCC_TC_VER"
   echo "MIN_GCC_TC_VERSION=$MIN_GCC_TC_VERSION"
   echo "DEFAULT_GCC_TC_VERSION=$DEFAULT_GCC_TC_VERSION"
   echo "CUSTOM_GCC_TC_VERSION=$CUSTOM_GCC_TC_VERSION"
   echo "ARCH_GCC_TC_VER=$ARCH_GCC_TC_VER"
   echo "ARCH_GCC_TC_EXT=$ARCH_GCC_TC_EXT"
   echo "USE_SYSCC=$USE_SYSCC"
   echo "CC=$CC"
   echo "CXX=$CXX"
   echo
}

