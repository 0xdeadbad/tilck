/* SPDX-License-Identifier: BSD-2-Clause */

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>

using namespace std;
using namespace filesystem;

struct gen_data {
   vector<string> modules;
};

static void
gen_includes(ostream &out, const gen_data &data)
{
   out << "/* This file is AUTO-GENERATED by the gen_config tool */\n";
   out << "\n";
   out << "#include <tilck/mods/sysfs.h>\n";
   out << "#include <tilck/mods/sysfs_utils.h>\n";
   out << "\n";

   out << "/* /syst/modules */\n";
   for (const string &mod: data.modules) {
      out << "#include <tilck_gen_headers/mod_" << mod << ".h>\n";
   }

   out << "\n";
}

static void
gen_globals(ostream &out, const gen_data &data)
{
   for (const string &mod: data.modules) {
      out << "DEF_STATIC_CONF_RO(BOOL, " << mod << ", MOD_" << mod << ");\n";
   }

   out << "\n";
}

static void
gen_config_directory(ostream &out,
                     const string &name,
                     const vector<string> &objects)
{
   out << "   name = \"" << name << "\";\n";
   out << R"(
   obj = sysfs_create_custom_obj(
      name,
      NULL,       /* hooks */

)";

   for (const string &obj : objects) {
      out << "      SYSOBJ_CONF_PROP_PAIR(" << obj << "),\n";
   }

   out <<R"(
      NULL
   );

   if (!obj)
      sysfs_fail_to_register_obj(name);

   if (sysfs_register_obj(NULL, &sysfs_root_obj, name, obj))
      sysfs_fail_to_register_obj(name);
)";
}

static void
gen_functions(ostream &out, const gen_data &data)
{
   out << R"(

static void
sysfs_fail_to_register_obj(const char *name)
{
   panic("sysfs: unable to register object '%s'", name);
}
)";

   out << R"(
static void
sysfs_create_autogenerated_objects(void)
{
   struct sysobj *obj;
   const char *name;


)";

   gen_config_directory(out, "modules", data.modules);

out << R"(
}
)";

}

int main(int argc, char **argv)
{
   if (argc < 3) {
      cerr << "Syntax: " << argv[0] << " <Tilck source dir> <Output file>\n";
      return 1;
   }

   const string projRoot = argv[1];
   const string outputFile = argv[2];
   const string modulesDir = projRoot + "/modules";

   gen_data data;

   for (auto &entry : directory_iterator(modulesDir)) {
      if (entry.is_directory()) {
         data.modules.push_back(entry.path().filename());
      }
   }

   ofstream out(outputFile);
   gen_includes(out, data);
   gen_globals(out, data);
   gen_functions(out, data);
   return 0;
}
