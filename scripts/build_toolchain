#!/bin/bash
# SPDX-License-Identifier: BSD-2-Clause

# GLOBAL VARIABLES

# Project's root directory
SOURCE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MAIN_DIR="$(cd $SOURCE_DIR/.. && pwd)"

# Constants
BUILD_ARCH="x86_64" # the only arch accepted for the build machine
X86_TOOLCHAIN_DIR_NAME="x86_gcc_toolchain"

# Arch-variables

if [[ "$ARCH" == "" ]]; then
   export ARCH="i386" # default target arch
fi

if [[ "$ARCH" == "i386" ]]; then

   ARCH_SHORT="x86"
   ARCH_FAMILY="generic_x86"
   ARCH_ELF_NAME="elf32-i386"
   ARCH_LD_OUTPUT="elf_i386"
   ARCH_EFI="ia32"
   ARCH_GCC_TC="i686"
   ARCH_GCC_FLAGS="-m32 -march=$ARCH_GCC_TC"
   ARCH_TC_DIR="$X86_TOOLCHAIN_DIR_NAME"

else
   echo "Architecture '$ARCH' not supported."
   exit 1
fi

echo
echo "ARCH=$ARCH"
echo

all_funcs_list=()

# Source files to include

source $MAIN_DIR/scripts/bash_includes/script_utils
source $MAIN_DIR/scripts/bash_includes/tc/install_pkgs
source $MAIN_DIR/scripts/bash_includes/tc/gcc_tc
source $MAIN_DIR/scripts/bash_includes/tc/cmake_download

###############################
# Mtools
###############################

all_funcs_list+=(build_mtools)
function build_mtools {

   pushd .

   if ! [ -d mtools ]; then

      show_work_on_component_msg "MTOOLS"
      local pkgname=mtools-4.0.23
      local tarname=$pkgname.tar.gz

      download_file_in_cache "ftp://ftp.gnu.org/gnu/mtools" "$tarname"
      extract_cachefile_tar_gz $tarname $pkgname mtools

      cd mtools
      run_command2 ./configure configure.log
      run_command2 "make -j" build.log
   else
      show_skip_component_msg "MTOOLS"
   fi

   popd
}


###############################
# LCOV (front end for GCOV)
###############################

all_funcs_list+=(build_lcov)
function build_lcov {

   pushd .
   if ! [ -d lcov ]; then

      show_work_on_component_msg "LCOV"

      local url="https://github.com/linux-test-project/lcov.git"
      git clone --branch v1.13 --depth 1 "$url"
      cd lcov
   else
      show_skip_component_msg "LCOV"
   fi
   popd

}

##############################
# Build gtest
##############################

all_funcs_list+=(build_gtest)
function build_gtest {

   pushd .

   if ! [ -d googletest ]; then
      url="https://github.com/google/googletest.git"
      git clone --branch release-1.8.0 --depth 1 "$url"
   fi

   if ! [ -d gtest ]; then

      show_work_on_component_msg "GOOGLE TEST (host arch)"
      mkdir gtest
      cd gtest

      $CMAKE -DCMAKE_BUILD_TYPE=Debug ../googletest/googletest
      run_command2 "make -j" build.log
   else
      show_skip_component_msg "GOOGLE TEST (host arch)"
   fi

   popd
}

all_funcs_list+=(build_gtest_arch)
function build_gtest_arch {

   pushd .

   if ! [ -d googletest ]; then
      local url="https://github.com/google/googletest.git"
      git clone --branch release-1.8.0 --depth 1 "$url"
   fi

   if ! [ -d gtest_arch ]; then

      show_work_on_component_msg "GOOGLE TEST (target arch)"
      download_gcc_glibc_toolchain

      mkdir gtest_arch
      cd gtest_arch

      local cc="${GCC_TOOLCHAIN_GLIBC}/${ARCH_GCC_TC}-linux-gcc"
      local cxx="${GCC_TOOLCHAIN_GLIBC}/${ARCH_GCC_TC}-linux-g++"
      CC=$cc CXX=$cxx $CMAKE -DCMAKE_BUILD_TYPE=Debug ../googletest/googletest
      run_command2 "make -j" build.log
   else
      show_skip_component_msg "GOOGLE TEST (target arch)"
   fi

   popd
}

##################################
# Build libmusl
##################################

all_funcs_list+=(build_libmusl)
function build_libmusl {

   pushd .
   local saved_path="$PATH"

   if ! [ -d musl ]; then

      if [[ "$USE_SYSCC" == "" || "$USE_SYSCC" == 0 ]]; then

         # The glibc gcc toolchain is necessary in order to build libmusl and
         # make its build system generate the musl-gcc script. Attempting to
         # build libmusl with the musl gcc toolchain succeeds BUT the musl-gcc
         # script and the lib/musl-gcc.specs file ARE NOT generated, because the
         # build system detected that the toolchain is already using libmusl. In
         # our case having the ability to build libmusl and compile programs
         # with musl-gcc is essential since it allows debugging libmusl itself
         # (the pre-compiled toolchain uses an optimized non-debug version of
         # libmusl).

         download_gcc_glibc_toolchain
         export PATH="$GCC_TOOLCHAIN_GLIBC:$PATH"

      else

         export SYS_CC="$CC"
         export SYS_CXX="$CXX"
         export CC="$MAIN_DIR/scripts/build_scripts/${ARCH}-gcc"
         export CXX="$MAIN_DIR/scripts/build_scripts/${ARCH}-g++"

      fi

      show_work_on_component_msg "LIBMUSL"

      git clone --branch v1.1.19 --depth 1 git://git.musl-libc.org/musl
      cd musl

      opts1="--target=${ARCH} --host=${ARCH} --build=${BUILD_ARCH}"
      opts2="--disable-shared --prefix=$TC/musl/install"
      opts3="--exec-prefix=$TC/musl/install --enable-debug"
      opts4="--syslibdir=$TC/musl/install/lib"

      run_command2 "./configure $opts1 $opts2 $opts3 $opts4" configure.log
      run_command2 "make -j" build.log
      run_command2 "make install" make_install.log

      cd $TC/musl/install/bin
      cp musl-gcc musl-g++
      sed -i 's/-${ARCH}-gcc/-${ARCH}-g++/' musl-g++

      cd $TC/musl/install/include
      ln -s /usr/include/linux .
      ln -s /usr/include/asm .
      ln -s /usr/include/asm-generic .

   else
      show_skip_component_msg "LIBMUSL"
   fi

   export PATH="$saved_path"
   popd
}

##################################
# Build GNU EFI
##################################

all_funcs_list+=(build_gnuefi)
function build_gnuefi {

   pushd .

   if ! [ -d gnu-efi ]; then

      show_work_on_component_msg "GNU-EFI"

      local url="https://github.com/vvaltchev/gnu-efi-fork.git"
      git clone --branch 3.0.8 --depth 1 "$url" gnu-efi
      cd gnu-efi
      run_command2 "make ARCH=${BUILD_ARCH} -j" build_${BUILD_ARCH}.log

      local arch_flags="ARCH=${ARCH_EFI} prefix=${ARCH_GCC_TC}-linux-"
      run_command2 "make $arch_flags -j" build_${ARCH_EFI}.log

   else
      show_skip_component_msg "GNU-EFI"
   fi

   popd
}


##################################
# Download OVMF
##################################

all_funcs_list+=(download_ovmf)
function download_ovmf {

   pushd .

   if ! [ -d ovmf ]; then

      show_work_on_component_msg "OVMF"

      mkdir ovmf
      cd ovmf

      url="https://www.kraxel.org/repos/jenkins/edk2/"
      wget -nd -r --no-parent -A 'edk2.git-ovmf-ia32*' "$url"
      wget -nd -r --no-parent -A 'edk2.git-ovmf-x64*' "$url"

      rpm2cpio edk2.git-ovmf-ia32* | cpio -idmv
      rpm2cpio edk2.git-ovmf-x64* | cpio -idmv

      mv ./usr/share/edk2.git/* .
      rm -rf ./usr
      rm -rf ./robots*
      rm -rf *.rpm

   else

      show_skip_component_msg "OVMF"
   fi

   popd
}

##################################
# Build busybox
##################################

all_funcs_list+=(config_busybox)
function config_busybox {

   if ! [ -d busybox ]; then
      echo "ERROR: busybox not found in toolchain"
      exit 1
   fi

   pushd busybox

   make menuconfig

   echo -n "Do you want to update busybox.config with the new config? [Y/n]: "
   read answer

   if [[ "$answer" == "" || "$answer" == "y" ]]; then
      cp .config $MAIN_DIR/other/busybox.config
      echo "Source file $MAIN_DIR/other/busybox.config UPDATED"
   fi

   popd
}

function internal_build_busybox {

   echo "Building busybox... "
   cp $MAIN_DIR/other/busybox.config .config
   export CROSS_COMPILE="${ARCH_GCC_TC}-linux-"
   run_command2 "make -j" build.log
   cp .config .last_build_config
   export CROSS_COMPILE=""
}

all_funcs_list+=(build_busybox)
function build_busybox {

   pushd .

   if [ -d busybox ]; then
      s1=`sha1sum ./busybox/.config | cut -d " " -f 1`
      s2=`sha1sum ./busybox/.last_build_config | cut -d " " -f 1`

      if [ "$s1" != "$s2" ]; then

         echo "Busybox: .config != .last_build_config"
         echo -n "Do you want to rebuild with the new config? [Y/n]: "
         read answer

         if [[ "$answer" == "" || "$answer" == "y" ]]; then

            echo -n "Do you want an incremental build? [Y/n]: "
            read answer
            if [[ "$answer" == "" || "$answer" == "y" ]]; then
               pushd busybox
               internal_build_busybox
               popd
            else
               rm -rf busybox
            fi
         fi
      fi
   fi

   if ! [ -d busybox ]; then

      show_work_on_component_msg "BUSYBOX"

      ver=1.28.4
      tarname=busybox-$ver.tar.bz2

      download_file_in_cache "https://busybox.net/downloads" "$tarname"
      extract_cachefile_tar_bz $tarname busybox-$ver busybox

      pushd busybox
      internal_build_busybox
      popd

   else
      show_skip_component_msg "BUSYBOX"
   fi

   popd
}

all_funcs_list+=(build_ncurses)
function build_ncurses {

   pushd .

   if ! [ -d ncurses ]; then

      ver=6.1
      tarname=ncurses-$ver.tar.gz

      download_file_in_cache "https://ftp.gnu.org/pub/gnu/ncurses" "$tarname"
      extract_cachefile_tar_gz $tarname ncurses-$ver ncurses

      mkdir -p ncurses/install
      cd ncurses

      opts1="--host=${ARCH_SHORT}-pc-linux-gnu --prefix=$TC/ncurses/install"
      opts2="--datarootdir=/usr/share --without-cxx --without-cxx-binding"
      opts3="--without-ada --without-manpages --without-dlsym"

      export CC="$GCC_TOOLCHAIN/${ARCH_GCC_TC}-linux-gcc"
      run_command2 "./configure $opts1 $opts2 $opts3" configure.log
      run_command2 "make -j" build.log
      run_command2 "make install" install.log
      export CC=""

   else
      show_skip_component_msg "NCURSES"
   fi

   popd
}

all_funcs_list+=(build_zlib)
function build_zlib {

   pushd .

   if ! [ -d zlib ]; then

      git clone --branch v1.2.11 --depth 1 https://github.com/madler/zlib
      cd zlib

      local p="$TC/zlib/install"
      CROSS_PREFIX="${ARCH_GCC_TC}-linux-" ./configure --prefix="$p" --static
      run_command2 "make -j" build.log
      run_command2 "make install" install.log

   else
      show_skip_component_msg "ZLIB"
   fi

   popd
}

##########################################################
#
# MAIN
#
##########################################################

if [[ "$USE_SYSCC" != "" && "$USE_SYSCC" != 0 ]]; then

   if [[ "$CC" == "" || "$CXX" == "" ]]; then
      echo "ERROR: setting CC and CXX is mandatory when USE_SYSCC=1."
      exit 1
   fi

   compiler="`$CC --version | cut -d ' ' -f 1 | head -1`"

   if [ "$compiler" != "gcc" ]; then
      echo "ERROR: USE_SYSCC=1 is NOT supported with compilers other than GCC."
      exit 1
   fi

fi

default_funcs=()
default_funcs+=(download_gcc_toolchain)
default_funcs+=(download_cmake)
default_funcs+=(build_gnuefi)
default_funcs+=(build_mtools)
default_funcs+=(build_zlib)

if [ -z "$NO_BUSYBOX" ]; then
   default_funcs+=(build_busybox)
fi

if [ "`uname -p`" != "$BUILD_ARCH" ]; then

   echo "ERROR: Tilck can be built ONLY on $BUILD_ARCH host machines no matter"
   echo "which target architecture has been chosen. Reason: the build "
   echo "system uses a toolchain pre-compiled for $BUILD_ARCH hosts."

   exit 1
fi

# Exit on the first failure
set -e

# Global toolchain directory
TC=$MAIN_DIR/toolchain

GCC_TOOLCHAIN=$TC/$ARCH_TC_DIR/bin # Default cross-compiler, in $PATH.
GCC_TOOLCHAIN_GLIBC=$TC/${ARCH_TC_DIR}_glibc/bin # NOTE: not in $PATH!
export PATH="$MAIN_DIR/scripts/build_scripts:$GCC_TOOLCHAIN:$PATH"

mkdir -p $TC
mkdir -p $TC/cache
cd $TC

# Set the CMAKE variable in order to single functions to be able to use it
if [ -f $TC/cmake/bin/cmake ]; then
   CMAKE=$TC/cmake/bin/cmake
else
   CMAKE=cmake
fi


if [ "$1" == "-s" ]; then

   if [ $# -ne 2 ]; then
      echo "Expected the name of the function to call after the $1 option"
   fi

   func="$2"

   if [ -n "$(type -t $func)" ] && [ "$(type -t $func)" = function ]; then
      echo "Executing single function '$func'"
      $func
   else
      echo "ERORR: The function '$func' does not exist."
      exit 1
   fi

   exit 0

elif [[ "$1" == "--help" || "$1" == "-h" ]]; then

   echo ""
   echo "Syntax:"
   echo "      $0 [-n]        run default functions"
   echo "      $0 -s <func>   run a specific function"
   echo ""
   echo "   -n    Do not check nor install system packages (advanced)"
   echo "           Even if many packages are downloaded & built by this script"
   echo "           without touching the system, some packages are required to"
   echo "           be installed in the system. For example: wget, git, make,"
   echo "           binutils, bzip2, rpmextract and others similar. When -n"
   echo "           is NOT passed, the script first tries to detect the current"
   echo "           Linux distribution and then it checks if all the required"
   echo "           packages are already installed. In case some packages need"
   echo "           to be installed, this script will show a list and run:"
   echo "               sudo <package manager> <list>"
   echo "           In case the user does not want this script to install the "
   echo "           necessary packages he/she could just interrupt this script"
   echo "           with Ctrl+C, without affecting the system."
   echo ""
   echo "Functions supported by this script (with -s):"
   echo ""

   for x in ${all_funcs_list[@]}; do
      echo -n "   - $x"
      for y in ${default_funcs[@]}; do
         if [ "$x" == "$y" ]; then
            echo -n " (*)"
         fi
      done
      echo ""
   done

   echo ""
   echo -e "(*) Default functions\n"
   exit 0
fi

# Single-option parsing

if [ "$1" == "-n" ] || [ "$1" == "--skip-install-pkgs" ]; then
   skip_install=true
fi

# The actual job

if [ -z "$skip_install" ]; then
   install_packages
else
   echo "*** SKIPPING installation of packages"
fi

echo
echo "*** Building the custom toolchain ***"
echo

for x in ${default_funcs[@]}; do
   $x
done

