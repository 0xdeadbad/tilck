#!/bin/bash

# GLOBAL VARIABLES

# Project's root directory
SOURCE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MAIN_DIR="$(cd $SOURCE_DIR/.. && pwd)"

X86_TOOLCHAIN_DIR_NAME="x86_gcc_toolchain"

source $MAIN_DIR/scripts/script_utils
source $MAIN_DIR/scripts/tc/install_pkgs
source $MAIN_DIR/scripts/tc/gcc_tc
source $MAIN_DIR/scripts/tc/cmake_download

###############################
# Mtools
###############################

function build_mtools {

   pushd .

   if ! [ -d mtools ]; then

      echo
      echo "*** MTOOLS ***"
      echo

      tarname=mtools-4.0.18.tar.gz
      wget ftp://ftp.gnu.org/gnu/mtools/$tarname
      tar xfz $tarname
      rm $tarname
      mv mtools-4.0.18 mtools
      cd mtools
      run_command2 ./configure configure.log
      run_command2 "make -j" build.log
   else
      echo "NOTE: Skipping mtools"
   fi

   popd
}


###############################
# LCOV (front end for GCOV)
###############################

function build_lcov {

   pushd .
   if ! [ -d lcov ]; then

      echo
      echo "*** LCOV ***"
      echo

      url="https://github.com/linux-test-project/lcov.git"
      git clone --branch v1.13 --depth 1 "$url"
      cd lcov
   else
      echo "NOTE: Skipping lcov"
   fi
   popd

}

###############################
# Build dietlibc [unused now]
###############################

function build_dietlibc {

   pushd .

   if ! [ -d dietlibc-0.33 ]; then

      echo
      echo "*** DIETLIBC ***"
      echo

      git clone --branch v0.33 --depth 1 https://github.com/vvaltchev/dietlibc-fork.git
      mv dietlibc-fork dietlibc-0.33

      pushd dietlibc-0.33

      sed -i 's/#define WANT_LINKER_WARNINGS/\/\/#define WANT_LINKER_WARNINGS/g' dietfeatures.h
      sed -i 's/-Wno-unused -Wredundant-decls/-Wno-unused -Wredundant-decls -fno-stack-protector/g' Makefile

      set +e
      PATH=$X86_TOOLCHAIN:$PATH make MYARCH=i386 -j i386 DEBUG=1 &> build.log
      set -e

      popd

   else

      echo "NOTE: Skipping dietlibc"

   fi

   popd

}

##############################
# Build gtest
##############################

function build_gtest {

   pushd .
   if ! [ -d googletest ]; then

      echo
      echo "*** GTEST ***"
      echo

      url="https://github.com/google/googletest.git"
      git clone --branch release-1.8.0 --depth 1 "$url"
      cd googletest/googletest
      $CMAKE -DCMAKE_BUILD_TYPE=Debug .
      run_command2 "make -j" build.log
   else
      echo "NOTE: Skipping googletest"
   fi
   popd

}

##################################
# Build libmusl
##################################

function build_libmusl {

   pushd .

   if ! [ -d musl ]; then

      # The glibc gcc toolchain is necessary in order to build libmusl and make
      # its build system generate the musl-gcc script. Attempting to build
      # libmusl with the musl gcc toolchain succeeds BUT the bin/musl-gcc script
      # and the lib/musl-gcc.specs file ARE NOT generated, because the build
      # system detected that the toolchain is already using libmusl. In our case
      # building libmusl and compiling programs with musl-gcc is essential since
      # it allows debugging libmusl itself (the pre-compiled toolchain uses an
      # optimized non-debug version of libmusl).

      download_x86_gcc_glibc_toolchain

      tc="$TC/${X86_TOOLCHAIN_DIR_NAME}_glibc/bin"
      saved_path="$PATH"
      export PATH="$tc:$PATH"

      echo
      echo "*** LIBMUSL ***"
      echo

      git clone --branch v1.1.19 --depth 1 git://git.musl-libc.org/musl
      cd musl

      opts1="--target=i386 --host=i386 --build=x86_64 --disable-shared"
      opts2="--prefix=$TC/musl-install --exec-prefix=$TC/musl-install"
      opts3="--enable-debug --syslibdir=$TC/musl-install/lib"

      run_command2 "./configure $opts1 $opts2 $opts3" configure.log
      run_command2 "make -j" build.log
      run_command2 "make install" make_install.log

      export PATH="$saved_path"

   else
      echo "NOTE: Skipping musl"
   fi

   popd

}

##################################
# Build GNU EFI
##################################

function build_gnuefi {

   pushd .

   if ! [ -d gnu-efi ]; then

      echo
      echo "*** GNU-EFI ***"
      echo

      url="https://github.com/vvaltchev/gnu-efi-fork.git"
      git clone --branch 3.0.8 --depth 1 "$url" gnu-efi
      cd gnu-efi
      run_command2 "make ARCH=x86_64 -j" build_x86_64.log
      run_command2 "make ARCH=ia32 prefix=i686-linux- -j" build_ia32.log

   else

      echo "NOTE: Skipping gnu-efi"

   fi

   popd
}


##################################
# Download OVMF
##################################

function download_ovmf {

   pushd .

   if ! [ -d ovmf ]; then

      mkdir ovmf
      cd ovmf

      url="https://www.kraxel.org/repos/jenkins/edk2/"
      wget -nd -r --no-parent -A 'edk2.git-ovmf-ia32*' "$url"
      wget -nd -r --no-parent -A 'edk2.git-ovmf-x64*' "$url"

      rpm2cpio edk2.git-ovmf-ia32* | cpio -idmv
      rpm2cpio edk2.git-ovmf-x64* | cpio -idmv

      mv ./usr/share/edk2.git/* .
      rm -rf ./usr
      rm -rf ./robots*
      rm -rf *.rpm

   else

      echo "NOTE: Skipping OVMF"
   fi

   popd
}

##################################
# Build busybox
##################################

function build_busybox {

   pushd .

   if ! [ -d busybox ]; then

      ver=1.28.4
      tarname=busybox-$ver.tar.bz2

      if ! [ -f $tarname ]; then
         wget https://busybox.net/downloads/$tarname
      else
         echo "NOTE: Skpping the download of $tarname"
      fi

      echo "Extracting the package... "
      tar xfj $tarname

      mv busybox-$ver busybox
      pushd busybox

      echo "Building busybox... "

      cp $MAIN_DIR/other/busybox.config .config
      export CROSS_COMPILE="i686-linux-"
      run_command2 "make -j" build.log

      popd
      rm $tarname

   else

      echo "NOTE: Skipping busybox"
   fi

   popd
}


##########################################################
#
# MAIN
#
##########################################################


# Exit on the first failure
set -e

# Toolchain dir
TC=$MAIN_DIR/toolchain

X86_TOOLCHAIN=$TC/$X86_TOOLCHAIN_DIR_NAME/bin
export PATH="$MAIN_DIR/scripts/build_scripts:$X86_TOOLCHAIN:$PATH"

mkdir -p $TC
cd $TC

# Set the CMAKE variable in order to single functions to be able to use it
if [ -f $TC/cmake/bin/cmake ]; then
   CMAKE=$TC/cmake/bin/cmake
else
   CMAKE=cmake
fi


if [ "$1" == "-s" ]; then

   if [ $# -ne 2 ]; then
      echo "Expected the name of the function to call after the $1 option"
   fi

   func="$2"

   if [ -n "$(type -t $func)" ] && [ "$(type -t $func)" = function ]; then
      echo "Executing single function '$func'"
      $func
   else
      echo "ERORR: The function '$func' does not exist."
      exit 1
   fi

   exit 0
fi

# Single-option parsing

if [ "$1" == "-n" ] || [ "$1" == "--skip-install-pkgs" ]; then
   skip_install=true
fi

# The actual job

if [ -z "$skip_install" ]; then
   install_packages
else
   echo "*** SKIPPING installation of packages"
fi

echo
echo "*** Building the custom toolchain ***"
echo

download_x86_gcc_toolchain
download_cmake
build_lcov
build_gtest
build_gnuefi
build_mtools

