#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-2-Clause

# GLOBAL VARIABLES

# Reset any forced env-based CFLAGS
export CFLAGS=""
export FFLAGS=""
export CXXFLAGS=""
export CFFLAGS=""

# Project's root directory
SOURCE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MAIN_DIR="$(cd "$SOURCE_DIR/.." && pwd)"
GCC_TC_CONF="$MAIN_DIR/other/gcc_tc_conf"

if [[ "$MAIN_DIR" = *" "* ]]; then
   echo "The Tilck source must be checked out in a path *WITHOUT* spaces"
   echo "Current path: '$MAIN_DIR'"
   exit 1
fi

all_funcs_list=()
install_funcs_list=()
config_funcs_list=()

# Source files to include
source $MAIN_DIR/scripts/bash_includes/script_utils
source $MAIN_DIR/scripts/bash_includes/arch_utils
source $MAIN_DIR/scripts/bash_includes/cc_vars
source $MAIN_DIR/scripts/bash_includes/arch_checks
source $MAIN_DIR/scripts/bash_includes/compiler_checks


ALL_ARCH_LIST="i386 x86_64 riscv64"
DEFAULT_ARCH="i386"
export MUSL_VER=${MUSL_VER:-1.2.5}
export ARCH=${ARCH:-$DEFAULT_ARCH}

#
# Setup the ARCH name according to convention used by pre-built toolchains
#
case $ARCH in
   i386) ARCH_GCC_TC="i686";;
   x86_64) ARCH_GCC_TC="x86_64";;
   riscv64) ARCH_GCC_TC="riscv64";;
   *) echo "Architecture '$ARCH' not supported."; exit 1;;
esac

# Default GCC toolchain version to use. Unfortunately, it depends on the target
# architecture, because the list of available pre-built toolchains on
# https://toolchains.bootlin.com depends on the architecture.

if ! [ -f $GCC_TC_CONF/$ARCH/default_ver ]; then
   echo "ERROR: file $GCC_TC_CONF/$ARCH/default_ver not found"
   exit 1
fi

DEFAULT_GCC_TC_VERSION=$(cat $GCC_TC_CONF/$ARCH/default_ver)
MIN_GCC_TC_VERSION=$(cat $GCC_TC_CONF/$ARCH/min_ver)

# Custom GCC toolchain from https://github.com/vvaltchev/musl-cross-make
# TODO: add a per-arch configuration file for this toolchain as well.
CUSTOM_GCC_TC_VERSION="11.4.0"

# Global toolchain directory

: ${TCROOT_PARENT:=$MAIN_DIR}
: ${TCROOT:=$TCROOT_PARENT/toolchain2}
TC="$TCROOT"

# Constants
BUILD_ARCH="x86_64" # offically supported build host architecture

set_host_arch_variable


# ARCH and ARCH_* variables are all about the TARGET architecture

if [[ "$GCC_TC_VER" == "" ]]; then

   if [ -f $TC/.gcc_tc_ver_$ARCH ]; then

      GCC_TC_VER=$(cat $TC/.gcc_tc_ver_$ARCH)

   else

      # GCC_TC_VER is not defined and there is no .gcc_tc_ver_$ARCH file.

      if [[ "$USE_CUSTOM_GCC_TC" == 1 ]]; then
         GCC_TC_VER=$CUSTOM_GCC_TC_VERSION    # Custom GCC toolchain
      elif [[ "$HOST_ARCH" == "$BUILD_ARCH" ]]; then
         GCC_TC_VER="$DEFAULT_GCC_TC_VERSION" # Main case, fully supported
      fi
   fi
fi

if [[ "$GCC_TC_VER" == "" ]]; then
   echo "ERROR: GCC_TC_VER is not set"
   exit 1
fi

#
# Support for our custom TC. Mandatory when HOST_ARCH != BUILD_ARCH, optional
# otherwise.
#
if [[ "$USE_CUSTOM_GCC_TC" == 1 ]]; then
   ARCH_GCC_TC_VER="custom"
fi

set_arch_variables $ARCH

#
# If $ARCH_GCC_TC_VER has not been set externally or by the check above,
# we'll use the pre-built bootlin toolchains, which do not use the GCC
# version in their name, but a year/month combination with additional
# fields. Therefore, let's map our desired GCC version to the bootlin
# toolchain name.
#
if [[ "$ARCH_GCC_TC_VER" == "" ]]; then
   set_arch_gcc_tc_ver $GCC_TC_VER
fi

if ! [ -f $TC/.gcc_tc_ver_$ARCH ]; then

   mkdir -p $TC
   echo -n $GCC_TC_VER > $TC/.gcc_tc_ver_$ARCH

else

   saved=$(cat $TC/.gcc_tc_ver_$ARCH)
   v=$GCC_TC_VER

   if ! [ "$GCC_TC_VER" = "$saved" ]; then
      echo "WARNING: GCC_TC_VER ($v) does not match with saved one ($saved)"
      echo "WARNING: This is NOT a supported scenario. Please delete:"
      echo "   $TC/$ARCH"
      echo "   $TC/.gcc_tc_ver_$ARCH"
      echo "And run this script again to use the new toolchain."
      exit 1
   fi
fi


# Compute $GCC_TC_VER_ from the base $GCC_TC_VER (e.g. "1.2.3" -> "1_2_3")
GCC_TC_VER_=$(echo $GCC_TC_VER | sed -E 's/[.]/_/g')
GCC_NAME_PFX="gcc_${GCC_TC_VER_}_${ARCH}"
MUSL_INSTALL=$TC/$ARCH/musl/install

dump_build_toolchain_env

function print_func {

   local fname="$1"
   local has_printf="$2"
   local is_default="$3"
   local def=""

   if [[ $is_default = 1 ]]; then
      def=" (*)"
   fi

   if [[ $has_printf = 1 ]]; then

      local attrs=""
      local extra_info=""
      local installed_func="${fname}_installed_status"

      if [[ "$(type -t $installed_func)" == 'function' ]]; then

         local status="$(eval $installed_func)"

         if [[ -n "$status" ]]; then

            if [[ "$status" =~ installed* ]]; then

               if ! [[ "$status" = "installed" ]]; then

                  extra_info=$(echo "$status" | cut -d ' ' -f 2-)
                  status="installed"
               fi
            fi

            status=$(printf "%-9s" "$status")
         fi

         case "$status" in

            installed*)
               status="$GREEN${status}$RATTRS"
            ;;

            error*)
               status="$RED${status}$RATTRS"
            ;;

            skipped*)
               status="$YELLOW${status}$RATTRS"
            ;;

         esac

         if [[ -n "$status" ]]; then
            attrs="$attrs[ $status ]"
         fi

         if [[ -n "$extra_info" ]]; then
            attrs="$attrs[ $extra_info ]"
         fi
      fi

      printf "%-35s $attrs\n" "$fname$def"

   else

      echo "   - $1 $def"
   fi
}

function show_help {

   echo ""
   echo "Syntax:"
   echo "      $0 [-n]                             run default functions"
   echo "      $0 -s func1 [func2 [func3 [...]]]   run specific functions"
   echo ""
   echo "   -n        Do not check nor install system packages (advanced)"
   echo "                Even if many packages are downloaded & built by this"
   echo "                script without touching the system, some packages are"
   echo "                required to be installed in the system. For example: "
   echo "                wget, git, make, binutils, bzip2, rpmextract and "
   echo "                others similar. When -n is NOT passed, the script "
   echo "                first tries to detect the current Linux distribution "
   echo "                and then it checks if all the required packages are "
   echo "                already installed. In case some packages need to be "
   echo "                installed, this script will show a list and run: "
   echo "                    sudo <package manager> install [pkg1 [pkg2 ...]]"
   echo "                In case the user does not want this script to install "
   echo "                the necessary packages he/she could just interrupt "
   echo "                this script with Ctrl+C, without affecting the "
   echo "                system."
   echo
   echo "   --clean   Remove everything from the toolchain, except the cache"
   echo ""
   echo "Functions supported by this script (with -s):"
   echo ""

   local has_printf=0
   local all_def_funcs=" ${default_funcs[*]} "

   if printf "" &> /dev/null; then
      has_printf=1
   fi

   for x in ${default_funcs[@]}; do
      print_func "$x" $has_printf 1
   done

   for x in ${all_funcs_list[@]}; do

      if [[ "$all_def_funcs" =~ " ${x} " ]]; then
         continue 2
      fi

      # Skip the config_* functions, in order to print them last
      if [[ "$x" =~ config_* ]]; then
         continue 2
      fi

      print_func "$x" $has_printf 0
   done

   # Now print all the config_* funcs
   for x in ${all_funcs_list[@]}; do
      if [[ "$x" =~ config_* ]]; then
         print_func "$x" $has_printf 0
      fi
   done

   echo ""
   echo -e "(*) Functions ran by default\n"
}

function show_error_no_func {
   echo "ERROR: The function '$1' does not exist. Re-run with --help."
}

function execute_func {

   if [ -n "$(type -t $1)" ] && [ "$(type -t $1)" = function ]; then

      echo "[build_toolchain] Executing single function '$1'"
      $1
      echo "[build_toolchain] Executing single function: DONE"

      return 0

   else

      return 1  # No such function
   fi
}

function check_func {

   local func="$1"

   for x in ${all_funcs_list[@]}; do
      if [[ "$x" == "$func" ||
            "$x" == "build_$func" ||
            "$x" == "download_$func" ]]
      then
         return 0
      fi
   done

   return 1 # Function not found
}

function perform_full_clean {

   echo "*** TOOLCHAIN CLEAN ***"
   if ! [ -d "$TC" ]; then
      exit 0
   fi

   cd "$TC"
   for x in *; do
      if [[ "$x" != "cache" ]]; then
         echo "Deleting '$x'..."
         rm -rf "$x"
      fi
   done
   rm -f .gcc_tc_ver_*
   echo "DONE"
   exit 0
}


##########################################################
#
# MAIN
#
##########################################################

function main {

   if [[ "$1" == "--clean" ]]; then
      perform_full_clean
      exit 0
   fi

   default_funcs=()

   if [[ "$USE_CUSTOM_GCC_TC" != "1" ]]; then
      # Default case
      default_funcs+=(download_gcc_musl)
   else
      # Special case, use the custom GCC toolchain
      default_funcs+=(custom_gcc_cross_tc)
   fi

   if [[ "$USE_SYSCC" == 1 ]]; then
      default_funcs+=(build_libmusl)
   fi

   if [[ "$HOST_ARCH" == "$BUILD_ARCH" ]]; then
      default_funcs+=(download_cmake)
   fi

   if [[ $ARCH_FAMILY == "generic_x86" ]]; then
      default_funcs+=(build_gnuefi)
   fi

   default_funcs+=(download_acpica)
   default_funcs+=(build_mtools)
   default_funcs+=(build_zlib)

   if [[ "$NO_BUSYBOX" != "1" ]]; then
      default_funcs+=(build_busybox)
   fi

   if [[ "$ARCH" == "riscv64" ]]; then

      export BOARD=${BOARD:-qemu-virt}
      export BOARD_BSP="$MAIN_DIR/other/bsp/$ARCH/$BOARD"
      source $BOARD_BSP/bootloader

      default_funcs+=(build_bootloader)
      default_funcs+=(build_libfdt)
   fi

   if [[ "$1" == "--help" || "$1" == "-h" ]]; then
      show_help
      exit 0
   fi

   # Compiler-related checks
   compiler_checks
   # Arch-related checks
   arch_checks
   # Save the current values of CC, CXX and related
   save_cc_vars

   # Exit on the first failure
   set -e

   export PATH="$MAIN_DIR/scripts/build_scripts:$PATH"
   local ha=$TC/host_${HOST_ARCH}

   if [[ "$USE_SYSCC" != 1 || "$HOST_ARCH" != "$ARCH" ]]; then
      GCC_TOOLCHAIN=$ha/${GCC_NAME_PFX}_musl/bin # Default cross-compiler
      GCC_TOOLCHAIN_GLIBC=$ha/${GCC_NAME_PFX}_glibc/bin # glibc cross-compiler
   fi

   if [[ "$USE_SYSCC" != 1 ]]; then

      # NOTE: GCC's musl pre-built toolchain overrides build_scripts/* in PATH.
      # This means that, when HOST_ARCH == BUILD_ARCH, i686-linux-gcc will use
      # its version and NOT the wrapper script in build_scripts which simulates
      # its behavior using -m32 and -specs.
      export PATH="$GCC_TOOLCHAIN:$PATH"

      # Also export the x86_64 cross-toolchain if it exists or if the host
      # is aarch64 since on that architecture, we need both the i386 and the
      # x86_64 toolchain in any case.
      export PATH="$ha/gcc_${GCC_TC_VER_}_x86_64_musl/bin:$PATH"

      unset ha
   fi


   if [ "$1" == "-s" ] && ! [ -d $TC/$ARCH ]; then

      echo
      echo "ERROR: directory $TC/$ARCH not found."
      echo
      echo "It is necessary to run this script *without* options first to "
      echo "download and build a minimum toolchain. Then, it will be possible"
      echo "to download and build the extra packages."
      echo
      echo "For more info: "
      echo "   https://github.com/vvaltchev/tilck/blob/master/docs/building.md"

      exit 1
   fi

   mkdir -p $TC
   mkdir -p $TC/cache
   mkdir -p $TC/noarch
   mkdir -p $TC/i386
   mkdir -p $TC/x86_64
   mkdir -p $TC/riscv64

   if [[ "$HOST_ARCH" == "aarch64" ]]; then
      mkdir -p $TC/host_aarch64
   else
      mkdir -p $TC/host_i386
      mkdir -p $TC/host_x86_64
   fi

   cd $TC

   if ! [ -L host ]; then
      ln -s host_${HOST_ARCH} host
   fi

   # Set the CMAKE variable in order to single functions to be able to use it
   if [ -f $TC/host_$HOST_ARCH/cmake/bin/cmake ]; then
      CMAKE=$TC/host_$HOST_ARCH/cmake/bin/cmake
   else
      CMAKE=cmake
   fi


   if [ "$1" == "-s" ]; then

      if [ $# -lt 2 ]; then
         echo "Expected the name of the function to call after the $1 option"
      fi

      shift  # Drop the first argument, $1

      for func in "$@"; do

         if ! check_func "$func"; then
            show_error_no_func "$func"
            exit 1
         fi

         if ! execute_func $func; then
            if ! execute_func "build_$func"; then
               if ! execute_func "download_$func"; then
                  show_error_no_func "$func"
                  exit 1
               fi
            fi
         fi

      done
      exit 0
   fi

   # Single-option parsing

   if [[ "$1" == "-n" || "$1" == "--skip-install-pkgs" ]]; then
      local skip_install=1
   fi

   # Do the actual job

   if [[ "$skip_install" == "" ]]; then
      install_packages
   else
      echo "*** SKIPPING installation of packages"
   fi

   echo
   echo "*** Building the custom toolchain ***"
   echo

   for x in ${default_funcs[@]}; do
      $x
   done

   echo
   echo "*** Building custom toolchain COMPLETED ***"
   echo
}

##########################################################
# Entry point: load package funcs and run main()
##########################################################

for x in $MAIN_DIR/scripts/tc/pkgs/*; do
   source $x
done

if command -v sort &> /dev/null 2>&1; then
   IFS=$'\n'
   all_funcs_list=($(sort <<<"${all_funcs_list[*]}"))
   unset IFS
fi

main "$@"
