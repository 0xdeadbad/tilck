#!/bin/bash

# GLOBAL VARIABLES

X86_TOOLCHAIN_DIR_NAME="x86_gcc_toolchain"

##############################################
# Internal utility functions
##############################################

function run_command {
   echo "Running command: $1"
   $1
}

function run_command2 {
   echo "Running command: $1 &> $2"
   $1 &> $2
}

pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

##############################################
# Install the necessary packages using apt
##############################################

ubuntu_pkg_list=()
ubuntu_pkg_list+=(wget)
ubuntu_pkg_list+=(git)
ubuntu_pkg_list+=(gcc)
ubuntu_pkg_list+=(g++)
ubuntu_pkg_list+=(make)
ubuntu_pkg_list+=(binutils)
ubuntu_pkg_list+=(qemu-system-x86)

function install_ubuntu_family {

   packages_list=( "${ubuntu_pkg_list[@]}" )
   to_install=()

   echo Checking the packages that need to be installed

   for x in ${packages_list[@]}; do
      echo -ne "Checking $x... "

      if [ "`dpkg -s $x 2>&1 | grep Status`" ]; then
         echo OK
      else
         echo NOT found
         to_install+=($x)
      fi
   done

   echo

   if [ ${#to_install[@]} -ne 0 ]; then
      echo ${#to_install[@]} packages need to be installed
      tmp="${to_install[@]}"
      run_command "sudo apt install $tmp"
   else
      echo "You are all set, no packages need to be installed."
   fi
}

function install_debian_family {

   packages_list=( "${ubuntu_pkg_list[@]}" )
   to_install=()

   echo Checking the packages that need to be installed

   for x in ${packages_list[@]}; do
      echo -ne "Checking $x... "

      if [ "`dpkg -s $x 2>&1 | grep Status`" ]; then
         echo OK
      else
         echo NOT found
         to_install+=($x)
      fi
   done

   echo

   if [ ${#to_install[@]} -ne 0 ]; then
      echo ${#to_install[@]} packages need to be installed
      tmp="${to_install[@]}"
      echo Running the command:
      echo su -c \"apt install $tmp\"
      su -c "apt install $tmp"
   else
      echo "You are all set, no packages need to be installed."
   fi
}

function install_fedora {

   packages_list=()
   packages_list+=(wget)
   packages_list+=(git)
   packages_list+=(gcc)
   packages_list+=(gcc-c++)
   packages_list+=(make)
   packages_list+=(binutils)
   packages_list+=(qemu-system-x86)
   packages_list+=(bzip2)

   to_install=()

   echo Checking the packages that need to be installed

   for x in ${packages_list[@]}; do
      echo -ne "Checking $x... "

      if dnf list installed $x &> /dev/null; then
         echo OK
      else
         echo NOT found
         to_install+=($x)
      fi
   done

   if [ ${#to_install[@]} -ne 0 ]; then
      echo ${#to_install[@]} packages need to be installed
      tmp="${to_install[@]}"
      run_command "sudo dnf install $tmp"
   else
      echo "You are all set, no packages need to be installed."
   fi
}


function install_packages {

   rel_files=`echo /etc/*release`
   lsb="/etc/lsb-release"
   os_rel="/etc/os-release"

   # Where lsb-release exists, use only it.
   # On Mint doing grep /etc/*release reports an error because there is an
   # upstream-release directory matching that wildcard. Using grep -r is not
   # a solution since in /etc/upstream-release/* on Mint, Ubuntu is mentioned.
   if [ -f $lsb ] && [ "$(grep -Ei 'buntu|mint' $lsb)" ]; then

      install_ubuntu_family

   # Debian does not contain the lsb-release file. Also, it needs a special
   # handling since it does not have 'sudo' by default. Installing sudo is not
   # a solution since the current use still won't be a sudoer and in general
   # does not make sense in such a script. The ubuntu script cannot made to use
   # su -c since by default the login to root is disabled. Only sudo -i works.
   elif [ -f $os_rel ] && [ "$(grep -Ei 'debian' $os_rel)" ]; then

      install_debian_family

   # On Fedora, we need to check if exactly a [Ff]edora-release file exists.
   elif echo $rel_files | grep -Ei 'fedora' - &> /dev/null; then

      install_fedora

   else

      pkg_list=()

      if ! which wget &> /dev/null; then
         pkg_list+=(wget)
      fi

      if ! which git &> /dev/null; then
         pkg_list+=(git)
      fi

      if ! which gcc &> /dev/null; then
         pkg_list+=(gcc)
      fi

      if ! which g++ &> /dev/null; then
         pkg_list+=(g++)
      fi

      if ! which make &> /dev/null; then
         pkg_list+=(make)
      fi

      if ! which objdump &> /dev/null; then
         pkg_list+=(binutils)
      fi

      if ! which qemu-system-x86_64 &> /dev/null; then
         pkg_list+=(qemu-system-x86)
      fi

      if [ ${#pkg_list[@]} -ne 0 ]; then

         echo "Your distribution is not fully supported by this script."
         echo "The supported distros are:"
         echo "  * Ubuntu"
         echo "  * Mint"
         echo "  * Debian"
         echo "  * Fedora"
         echo "In order to compile exOS on this distro, please make sure the "
         echo "following packages (ubuntu package names) are installed:"

         for x in ${pkg_list[@]}; do
            echo "  * $x"
         done

         echo "After that, re-run this script with the option --skip-install-pkgs"
         exit 1

      fi
   fi

}

###############################
# Nasm
###############################

function build_nasm {

   pushd .

   if ! [ -d nasm ]; then

      echo
      echo "*** NASM ***"
      echo

      tarname=nasm-2.13.02.tar.gz
      wget http://www.nasm.us/pub/nasm/releasebuilds/2.13.02/$tarname
      tar xfz $tarname
      rm $tarname
      mv nasm-2.13.02 nasm
      cd nasm
      run_command2 ./configure configure.log
      run_command2 "make -j" build.log
   else
      echo "NOTE: Skipping nasm"
   fi

   popd
}

###############################
# Mtools
###############################

function build_mtools {

   pushd .

   if ! [ -d mtools ]; then

      echo
      echo "*** MTOOLS ***"
      echo

      tarname=mtools-4.0.18.tar.gz
      wget ftp://ftp.gnu.org/gnu/mtools/$tarname
      tar xfz $tarname
      rm $tarname
      mv mtools-4.0.18 mtools
      cd mtools
      run_command2 ./configure configure.log
      run_command2 "make -j" build.log
   else
      echo "NOTE: Skipping mtools"
   fi

   popd
}


###############################
# x86-i686 GNU toolchain
###############################

function download_x86_gcc_toolchain {

   pushd .

   if ! [ -d $X86_TOOLCHAIN_DIR_NAME ]; then

      echo
      echo "*** i686 GCC TOOLCHAIN ***"
      echo

      # bleeding-edge
      #tcname=x86-i686--glibc--bleeding-edge-2018.02-1

      # stable
      tcname=x86-i686--glibc--stable-2018.02-2
      tarname=$tcname.tar.bz2
      url=http://toolchains.bootlin.com/downloads/releases/toolchains
      wget $url/x86-i686/tarballs/$tarname
      tar xfj $tarname
      rm $tarname
      mv $tcname $X86_TOOLCHAIN_DIR_NAME
      cd $X86_TOOLCHAIN

      for x in *; do
         if [[ $x == i686* ]]; then
            new_name=`echo $x | sed 's/i686/i386/g' -`
            ln -s $x $new_name
         fi
      done

      # To make musl-gcc happy

      for x in *; do
         if [[ $x == i386-linux-* ]]; then
            new_name=`echo $x | sed 's/i386-linux-/i386-/g' -`
            ln -s $x $new_name
         fi
      done

   else
      echo "NOTE: Skipping x86-i686 GNU toolchain"
   fi

   popd
}


###############################
# CMake
###############################

function build_cmake_internal {

   echo
   echo "*** CMAKE ***"
   echo

   wget https://cmake.org/files/v3.7/cmake-3.7.0-Linux-x86_64.tar.gz
   tar xf cmake-3.7.0-Linux-x86_64.tar.gz
   mv cmake-3.7.0-Linux-x86_64 cmake
   CMAKE=$TC/cmake/bin/cmake
   rm cmake-3.7.0-Linux-x86_64.tar.gz
}

function build_cmake {

   pushd .

   if ! [ -d cmake ]; then

      if ! which cmake &> /dev/null; then

         # CMake is not installed on the machine, download it.
         build_cmake_internal

      else

         # CMake is installed: let's check its version
         ver=`cmake --version | head -1 | grep -Eo '[0-9]+[.][0-9]+[.][0-9]+' | head -1`
         major=`echo -ne $ver | grep -Eo '[0-9]+' | head -1`
         minor=`echo -ne $ver | grep -Eo '[0-9]+' | head -2 | tail -1`

         if [ $major -lt 3 ]; then

            # The installed CMake is too old.
            build_cmake_internal

         elif [ $minor -lt 2 ]; then

            # The installed CMake is too old. Ver >= 3.2 is required.
            build_cmake_internal

         else

            # The installed version is >= 3.2. Using it.
            CMAKE=cmake
            echo "NOTE: Using system's CMake (version $major.$minor)"

         fi

      fi

   else
      echo "NOTE: Skipping CMake"
   fi

   popd
}

###############################
# LCOV (front end for GCOV)
###############################

function build_lcov {

   pushd .
   if ! [ -d lcov ]; then

      echo
      echo "*** LCOV ***"
      echo

      git clone --branch v1.13 --depth 1 https://github.com/linux-test-project/lcov.git
      cd lcov
   else
      echo "NOTE: Skipping lcov"
   fi
   popd

}

###############################
# Build dietlibc
###############################

function build_dietlibc {

   pushd .

   if ! [ -d dietlibc-0.33 ]; then

      echo
      echo "*** DIETLIBC ***"
      echo

      git clone --branch v0.33 --depth 1 https://github.com/vvaltchev/dietlibc-fork.git
      mv dietlibc-fork dietlibc-0.33

      pushd dietlibc-0.33

      sed -i 's/#define WANT_LINKER_WARNINGS/\/\/#define WANT_LINKER_WARNINGS/g' dietfeatures.h
      sed -i 's/-Wno-unused -Wredundant-decls/-Wno-unused -Wredundant-decls -fno-stack-protector/g' Makefile

      set +e
      PATH=$X86_TOOLCHAIN:$PATH make MYARCH=i386 -j i386 DEBUG=1 &> build.log
      set -e

      popd

   else

      echo "NOTE: Skipping dietlibc"

   fi

   popd

}

##############################
# Build gtest
##############################

function build_gtest {

   pushd .
   if ! [ -d googletest ]; then

      echo
      echo "*** GTEST ***"
      echo

      git clone --branch release-1.8.0 --depth 1 https://github.com/google/googletest.git
      cd googletest/googletest
      $CMAKE -DCMAKE_BUILD_TYPE=Debug .
      run_command2 "make -j" build.log
   else
      echo "NOTE: Skipping googletest"
   fi
   popd

}

##################################
# Build libmusl (unused for now)
##################################

function build_libmusl {

   pushd .

   if ! [ -d musl ]; then

      echo
      echo "*** LIBMUSL ***"
      echo

      git clone --branch v1.1.19 --depth 1 git://git.musl-libc.org/musl
      cd musl

      opts1="--target=i386 --host=i386 --build=x86_64 --disable-shared"
      opts2="--prefix=$TC/musl-install --exec-prefix=$TC/musl-install"
      opts3="--enable-debug --syslibdir=$TC/musl-install/lib"

      run_command2 "./configure $opts1 $opts2 $opts3" configure.log
      run_command2 "make -j" build.log
      run_command2 "make install" make_install.log
   else
      echo "NOTE: Skipping musl"
   fi

   popd

}

##################################
# Build GNU EFI
##################################

function build_gnuefi {

   pushd .

   if ! [ -d gnu-efi ]; then

      echo
      echo "*** GNU-EFI ***"
      echo

      git clone --branch 3.0.8 --depth 1 https://github.com/vvaltchev/gnu-efi-fork.git gnu-efi
      cd gnu-efi
      run_command2 "make ARCH=x86_64 -j" build_x86_64.log
      run_command2 "make ARCH=ia32 prefix=i686-linux- -j" build_ia32.log

   else

      echo "NOTE: Skipping gnu-efi"

   fi

   popd
}


##################################
# Download OVMF
##################################

function download_ovmf {

   pushd .

   if ! [ -d ovmf ]; then

      mkdir ovmf
      cd ovmf

      wget -nd -r --no-parent -A 'edk2.git-ovmf-ia32*' https://www.kraxel.org/repos/jenkins/edk2/
      wget -nd -r --no-parent -A 'edk2.git-ovmf-x64*' https://www.kraxel.org/repos/jenkins/edk2/

      rpm2cpio edk2.git-ovmf-ia32* | cpio -idmv
      rpm2cpio edk2.git-ovmf-x64* | cpio -idmv

      mv ./usr/share/edk2.git/* .
      rm -rf ./usr
      rm -rf ./robots*
      rm -rf *.rpm

   else

      echo "NOTE: Skipping OVMF"
   fi

   popd
}

##########################################################
#
# MAIN
#
##########################################################


# Exit on the first failure
set -e

# Project's root directory
MAIN_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MAIN_DIR=$MAIN_DIR/..

# Toolchain dir
TC=$MAIN_DIR/toolchain

X86_TOOLCHAIN=$TC/$X86_TOOLCHAIN_DIR_NAME/bin
export PATH="$MAIN_DIR/scripts/build_scripts:$X86_TOOLCHAIN:$PATH"

mkdir -p $TC
cd $TC

# Set the CMAKE variable in order to single functions to be able to use it
if [ -f $TC/cmake/bin/cmake ]; then
   CMAKE=$TC/cmake/bin/cmake
else
   CMAKE=cmake
fi


if [ "$1" == "-s" ]; then

   if [ $# -ne 2 ]; then
      echo "Expected the name of the function to call after the $1 option"
   fi

   func="$2"

   if [ -n "$(type -t $func)" ] && [ "$(type -t $func)" = function ]; then
      echo "Executing single function '$func'"
      $func
   else
      echo "ERORR: The function '$func' does not exist."
      exit 1
   fi

   exit 0
fi

# Single-option parsing

if [ "$1" == "-n" ] || [ "$1" == "--skip-install-pkgs" ]; then
   skip_install=true
fi

# The actual job

if [ -z "$skip_install" ]; then
   install_packages
else
   echo "*** SKIPPING installation of packages"
fi

echo
echo "*** Building the custom toolchain ***"
echo

download_x86_gcc_toolchain
build_cmake
build_lcov
build_dietlibc
build_gtest
build_gnuefi
build_mtools

