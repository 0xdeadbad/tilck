#!/usr/bin/python
# SPDX-License-Identifier: BSD-2-Clause

import os
import re
import sys
import time
import signal
import subprocess
import threading

# Constants
BUILD_DIR = r'@CMAKE_BINARY_DIR@'
KERNEL_ELF = r'@KERNEL_FILE@'

error_codes_strings = {
   0: 'success',
   1: 'invalid_arguments',
   2: 'reboot',
   3: 'timeout',
   4: 'panic',
   5: 'shell_no_zero_exit',
   6: 'gcov_issue'
}

SHORT_TEST_TIMEOUT = 12
MED_TEST_TIMEOUT   = 24
LONG_TEST_TIMEOUT  = 36

# Global variables
shell_cmd_tests = [ ]
selftests = [ ]

selftests_to_run = 0
selftests_passed = 0
shell_cmd_tests_to_run = 0
shell_cmd_tests_passed = 0


def load_list_of_shell_cmd_tests():

   global shell_cmd_tests

   tt_short = SHORT_TEST_TIMEOUT
   tt_med = MED_TEST_TIMEOUT
   tt_long = LONG_TEST_TIMEOUT

   devshell = os.path.join(BUILD_DIR, 'usermode_apps', 'devshell')
   output = subprocess.check_output([devshell, '-l'])
   arr = output.split("\n")

   for r in arr:

      r = r.rstrip()

      if not r:
         continue

      name, tt = r.split(' ')
      tt = locals()[tt]
      shell_cmd_tests.append([name, tt])

def load_list_of_kernel_self_tests():

   global selftests

   rows = subprocess.check_output(['nm', KERNEL_ELF]).split("\n")

   short = SHORT_TEST_TIMEOUT
   med = MED_TEST_TIMEOUT
   long = LONG_TEST_TIMEOUT

   for row in rows:

      row = row.rstrip()

      if not row:
         continue

      vaddr, t, name = row.split(' ')

      if not name.startswith('selftest_'):
         continue

      comps = name.split('_')
      tt = comps[-1]

      if tt not in ['short', 'med', 'long']:
         continue

      name = '_'.join(comps[1:])
      tt = locals()[tt]
      selftests.append([name, tt])

def internal_run_test(test_type, test, timeout, show_output = False):

   print "[ RUNNING ] {0}: '{1}' [timeout: {2}]".format(test_type,test,timeout)
   start_time = time.time()

   try:
      output = subprocess.check_output(['@CMAKE_BINARY_DIR@/st/single_test_run',
                                        test_type,
                                        test,
                                        str(timeout)],
                                        stderr=subprocess.STDOUT)
   except subprocess.CalledProcessError as e:
      elapsed = time.time() - start_time
      print e.output
      print "[ FAILED  ] after %.2f seconds with: %s\n" % \
            (elapsed, error_codes_strings[e.returncode])
      return False

   elapsed = time.time() - start_time

   if show_output:
      print("")
      print(output)

   print "[ PASSED  ] after %.2f seconds\n" % elapsed
   return True

def show_help_and_exit():
   print "Syntax:"
   print "     ./system_tests/run_all_tests -l"
   print "     ./system_tests/run_all_tests [-o] [<max_timeout>]"
   print "     ./system_tests/run_all_tests [-o] <regex> [<max_timeout>]"
   sys.exit(1)

def show_tests_and_exit():

   col_names = [['test name', 30], ['test type', 12],  ['timeout', 10]]
   print("")

   for x in col_names:
      sys.stdout.write('+-')
      sys.stdout.write(''.center(x[1], '-'))
   sys.stdout.write('+\n')

   for x in col_names:
      sys.stdout.write('| ')
      sys.stdout.write(x[0].center(x[1], ' '))
   sys.stdout.write('|\n')

   for x in col_names:
      sys.stdout.write('+-')
      sys.stdout.write(''.center(x[1], '-'))
   sys.stdout.write('+\n')

   for x in selftests:
      sys.stdout.write('| ')
      sys.stdout.write(x[0].ljust(col_names[0][1]))
      sys.stdout.write('| ')
      sys.stdout.write('self test'.ljust(col_names[1][1]))
      sys.stdout.write('| ')
      sys.stdout.write(str(x[1]).ljust(col_names[2][1]))
      sys.stdout.write('|\n')

   for x in shell_cmd_tests:
      sys.stdout.write('| ')
      sys.stdout.write(x[0].ljust(col_names[0][1]))
      sys.stdout.write('| ')
      sys.stdout.write('shell cmd'.ljust(col_names[1][1]))
      sys.stdout.write('| ')
      sys.stdout.write(str(x[1]).ljust(col_names[2][1]))
      sys.stdout.write('|\n')

   for x in col_names:
      sys.stdout.write('+-')
      sys.stdout.write(''.center(x[1], '-'))
   sys.stdout.write('+\n')

   sys.stdout.write('\n')
   sys.exit(0)


def run_selftest(x, show_output):

   global selftests_to_run, selftests_passed

   if not selftests_to_run:
      print("")

   selftests_to_run += 1
   if internal_run_test('selftest', x[0], x[1], show_output):
      selftests_passed += 1

def run_shellcmd_test(x, show_output):

   global selftests_to_run, shell_cmd_tests_to_run
   global shell_cmd_tests_passed

   if not selftests_to_run and not shell_cmd_tests_to_run:
      print("")

   shell_cmd_tests_to_run += 1
   if internal_run_test('shellcmd', x[0], x[1], show_output):
      shell_cmd_tests_passed += 1

def main():

   # Options
   max_test_timeout = MED_TEST_TIMEOUT
   show_output = False
   reg = ".*"
   # ------------

   load_list_of_shell_cmd_tests()
   load_list_of_kernel_self_tests()

   if len(sys.argv) >= 2:

      if sys.argv[1] == '-l':
         show_tests_and_exit()

      if sys.argv[1] == '-o':
         show_output = True
         del sys.argv[1]

      if sys.argv[1].startswith('-'):
         show_help_and_exit()

      try:
         max_test_timeout = int(sys.argv[1])
      except:
         reg = sys.argv[1]

      if len(sys.argv) >= 3:
         try:
            max_test_timeout = int(sys.argv[2])
         except:
            show_help_and_exit()

   for x in selftests:
      if re.match(reg, x[0]):
         if x[1] <= max_test_timeout:
            run_selftest(x, show_output)


   for x in shell_cmd_tests:
      if re.match(reg, x[0]):
         if x[1] <= max_test_timeout:
            run_shellcmd_test(x, show_output)

   if selftests_to_run + shell_cmd_tests_to_run == 0:
      print("ERROR: No tests matching the '{0}' regex".format(reg))
      sys.exit(1)

   print "-" * 80

   if shell_cmd_tests_to_run:
      print "Shell cmd tests passed: {0}/{1}".format(shell_cmd_tests_passed,
                                                     shell_cmd_tests_to_run)

   if selftests_to_run:
      print "Self tests passed: {0}/{1}".format(selftests_passed,
                                                selftests_to_run)

   total_to_run = shell_cmd_tests_to_run + selftests_to_run
   total_passed = shell_cmd_tests_passed + selftests_passed

   if total_passed != total_to_run:
      sys.exit(1)

###############################
if __name__ == '__main__':
   main()
