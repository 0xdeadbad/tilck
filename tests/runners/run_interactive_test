#!/usr/bin/python3
# SPDX-License-Identifier: BSD-2-Clause
# pylint: disable=unused-wildcard-import

import os
import re
import sys
import time
import signal
import subprocess
import threading
import struct
import fcntl
import filecmp
import traceback
from collections import namedtuple

# Constants coming from CMake (this file gets pre-processed by CMake)
RUNNERS_DIR = "@CMAKE_SOURCE_DIR@/tests/runners"
TILCK_IMAGE = "@IMG_FILE@"
TMP_DIR = "@CMAKE_BINARY_DIR@/tmp"

CMAKE_CONFIG = {
   "EXTRA_VIM" : ("@EXTRA_VIM@", True),
   "FB_CONSOLE_BANNER" : ("@FB_CONSOLE_BANNER@", False),
   "FB_CONSOLE_BLINK" : ("@FB_CONSOLE_BLINK@", False),
   "FB_CONSOLE_USE_ALT_FONTS" : ("@FB_CONSOLE_USE_ALT_FONTS@", False),
   "SERIAL_CON_IN_VIDEO_MODE" : ("@SERIAL_CON_IN_VIDEO_MODE@", True),
   "BOOTLOADER_LEGACY" : ("@BOOTLOADER_LEGACY@", True),
   "MOD_console" : ("@MOD_console@", True),
   "MOD_serial" : ("@MOD_serial@", True),
   "MOD_fb" : ("@MOD_fb@", True),
   "MOD_kb8042" : ("@MOD_kb8042@", True)
}

sys.path.append(RUNNERS_DIR)
from lib import qemu
from lib.utils import *
from lib.detect_kvm import *
from lib.env import *

# Other constants
STABLE_SCREENSHOT_DELAY   = 0.25
STABLE_SCREENSHOT_TIMEOUT = 3.00

# Exceptions

class StableScreenshotFailure(Exception):
   def __init__(self):
      msg = "Unable to take a stable screenshot in {}s"
      msg = msg.format(STABLE_SCREENSHOT_TIMEOUT)
      super(StableScreenshotFailure, self).__init__(msg)

class ConvertFailure(Exception):
   def __init__(self, msg):
      super(ConvertFailure, self).__init__(msg)

# Environment config variables
VM_MEMORY_SIZE_IN_MB = int(os.environ.get('TILCK_VM_MEM', '128'))

# Global state variables
g_process = None
g_fail_reason = Fail.success
g_dumping_gcda_files = False
g_timeout = 20
g_next_screenshot = 0

def set_once_qemu_process(p):
   global g_process
   assert(g_process is None)
   g_process = p

def set_once_fail_reason(reason: Fail):
   global g_fail_reason
   assert(g_fail_reason == Fail.success)
   g_fail_reason = reason

def check_cmake_config():

   for k in CMAKE_CONFIG:

      pair = CMAKE_CONFIG[k]
      val, exp = is_cmake_opt_enabled(pair[0]), pair[1]

      if val != exp:
         msg_print("INVALID CONFIG: expected {} to be `{}`".format(k, exp))

         if g_fail_reason == Fail.success:
            set_once_fail_reason(Fail.invalid_build_config)

   if g_fail_reason != Fail.success:
      sys.exit(g_fail_reason.value)

def wait_for_qemu_to_exit():
   while g_process.poll() is None:
      time.sleep(0.1)

def recv_from_qemu_monitor():

   read_anything = False
   buf = ''

   while True:

      text = g_process.stdout.read()

      # Is there any new text?
      if text:
         buf += text.decode('latin-1')
         read_anything = True
         time.sleep(0.05)
         continue

      # Nope. Did we read anything in the previous iteration?
      if read_anything:
         return buf # yep, return.

      # Nope. Is the VM still alive?
      if g_process.poll() is not None:
         return '' # Nope. Return an empty string

      # Yep. Wait for some text
      time.sleep(0.1)

def echo_qemu_monitor():
   text = recv_from_qemu_monitor()
   raw_stdout_write(text)

def send_to_qemu_monitor(cmd, delay = 0.2):
   g_process.stdin.write("{}\n".format(cmd).encode('latin-1'))
   g_process.stdin.flush()
   time.sleep(delay)
   echo_qemu_monitor()

def send_single_key_to_vm(key):

   key_name = None

   if not key:
      return

   if len(key) > 1:
      key_name = key
   else:
      key_name = qemu.KEYS_MAP.get(key, None)

   if key_name is not None:
      send_to_qemu_monitor("sendkey " + key_name)

def send_string_to_vm(s):
   for k in s:
      send_single_key_to_vm(k)

def run(test_func):

   args = [
      'qemu-system-i386',
      '-m', str(VM_MEMORY_SIZE_IN_MB),
      '-display', 'none',
      '-monitor', 'stdio',
      '-device', 'isa-debug-exit,iobase=0xf4,iosize=0x04',
      '-drive', 'id=img1,format=raw,if=none,file=' + TILCK_IMAGE,
      '-device', 'ide-hd,drive=img1,cyls=74,heads=16,secs=63'
   ]

   if is_kvm_installed():
      args.append('-enable-kvm')

   # Run the QEMU process by using a PIPE for its stdout
   p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
   set_once_qemu_process(p)

   # Get the current flags for the `stdout` file descriptor
   fl = fcntl.fcntl(g_process.stdout.fileno(), fcntl.F_GETFL)

   # Make the `stdout` file descriptor non-blocking
   fcntl.fcntl(g_process.stdout.fileno(), fcntl.F_SETFL, fl | os.O_NONBLOCK)

   raw_print('-' * 80)
   start_time = time.time()
   echo_qemu_monitor()

   try:

      # Call the test func
      test_func()

   except StableScreenshotFailure as e:
      msg_print("Exception: " + str(e))
      set_once_fail_reason(Fail.timeout)

   except Exception as e:
      msg_print("Exception: " + str(e))
      set_once_fail_reason(Fail.other)

   send_to_qemu_monitor("quit")
   wait_for_qemu_to_exit()

   elapsed = time.time() - start_time
   raw_print('-' * 80)
   msg_print("Elapsed: {:.2f} s".format(elapsed))

def delete_old_screenshots():

   for f in os.listdir():

      if not os.path.isfile(f):
         continue

      if re.match("s[0-9]+[.](ppm|pbm|png)", f):
         os.remove(f)

def img_convert(img, newtype):

   cmd = ["convert"]

   if newtype == "pbm":
      cmd += [
         "-filter", "catrom",
         "-colorspace", "gray", "+dither",
         "-colors", "2",
         "-negate"
      ]

   name, ext = os.path.splitext(img)

   cmd.append(img)
   cmd.append("-strip")
   cmd.append(name + "." + newtype)
   res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

   if res.returncode != 0:
      out = res.stdout.decode('utf-8')
      err = res.stderr.decode('utf-8')
      raise ConvertFailure("stdout: '{}'\nstderr: '{}'".format(out, err))

def vm_take_screenshot():

   global g_next_screenshot

   name = "s{:03}".format(g_next_screenshot)
   ppm_name = name + ".ppm"
   send_to_qemu_monitor("screendump " + ppm_name)
   img_convert(ppm_name, "png")
   os.remove(ppm_name)
   g_next_screenshot += 1
   return name + ".png"

def vm_take_stable_screenshot():

   time_elapsed = 0.0
   prevs = [vm_take_screenshot()]
   curr = None

   while True:

      time_elapsed += STABLE_SCREENSHOT_DELAY

      if time_elapsed >= STABLE_SCREENSHOT_TIMEOUT:
         raise StableScreenshotFailure()

      time.sleep(STABLE_SCREENSHOT_DELAY)
      curr = vm_take_screenshot()

      if filecmp.cmp(prevs[-1], curr, False):
         break # Bang! We got two identical screenshots.

      # We screenshots differ.
      if len(prevs) > 1:

         # We have more than 1 old screeshot. Could be the cursor blinking?
         if filecmp.cmp(prevs[-2], curr, False):
            break # Assume it's cursor blinking.

      # We have to save this screenshot
      prevs.append(curr)

   # Great, we're out of the loop. Let's delete the useless screenshots.
   for s in prevs:
      os.remove(s)

   return curr


def trivial_func():
   vm_take_stable_screenshot()
   time.sleep(1)
   vm_take_stable_screenshot()
   time.sleep(1)
   send_string_to_vm("1")
   time.sleep(1)
   vm_take_stable_screenshot()
   send_string_to_vm("ls -l")
   send_single_key_to_vm("ret")
   vm_take_stable_screenshot()

def setup_tmp_dir():

   if not os.path.isdir(TMP_DIR):
      os.mkdir(TMP_DIR)

   os.chdir(TMP_DIR)
   delete_old_screenshots()

def check_system_config():

   found = False
   exTrace = None

   try:

      res = subprocess.run(["convert"], stdout=subprocess.PIPE)
      out = res.stdout.decode("utf-8")
      if out.find("ImageMagick") != -1:
         found = True

   except Exception:
      exTrace = traceback.format_exc()

   if not found:
      msg_print("ERROR: ImageMagick (convert tool) not found on the system")
      msg_print("Exception:\n{}".format(exTrace))
      sys.exit(Fail.invalid_system_config)

def main():

   set_runner_name("interactive tests runner")
   check_cmake_config()
   check_system_config()
   detect_kvm()
   setup_tmp_dir()

   thread = threading.Thread(target = run, args = (trivial_func,))
   thread.start()
   thread.join(g_timeout)

   if thread.is_alive():

      # If we get here, after `g_params.timeout`, the test is still running

      if g_dumping_gcda_files:

         # If we're just dumping the GCDA file, wait a little more
         thread.join(30)

      if thread.is_alive():
         # We have to fail with timeout
         set_once_fail_reason(Fail.timeout)
         print_timeout_kill_vm_msg(g_timeout)
         g_process.send_signal(signal.SIGINT)
         thread.join()

   sys.exit(g_fail_reason.value)

###############################
if __name__ == '__main__':
   main()
