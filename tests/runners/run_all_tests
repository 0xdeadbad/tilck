#!/usr/bin/env python3
# SPDX-License-Identifier: BSD-2-Clause
# pylint: disable=unused-wildcard-import

import os
import re
import sys
import time
import signal
import argparse
import subprocess
import threading
import concurrent.futures as ft
from typing import List, Dict

# Constants coming from CMake (this file gets pre-processed by CMake)
RUNNERS_DIR = '@CMAKE_SOURCE_DIR@/tests/runners'
KERNEL_FILE = '@KERNEL_FILE@'
BUILD_DIR = '@CMAKE_BINARY_DIR@'
KERNEL_FORCE_TC_ISYSTEM = '@KERNEL_FORCE_TC_ISYSTEM@'

sys.path.append(RUNNERS_DIR)
from lib.utils import *
from lib.detect_kvm import *
from lib.env import *
from lib.exceptions import *

# Constants

SHORT_TEST_TIMEOUT  =    12
MED_TEST_TIMEOUT    =    36
LONG_TEST_TIMEOUT   =    72
MANUAL_TEST_TIMEOUT = 10000         # More convenient than 0 for sorting

load_tests_func_by_type_list = [
   'load_list_of_kernel_self_tests',
   'load_list_of_shell_cmd_tests'
]

tt_pretty_names = {
   val: TEST_TYPES_PRETTY[i] for i, val in enumerate(TEST_TYPES)
}

load_tests_func_by_type = {
   val: load_tests_func_by_type_list[i] for i, val in enumerate(TEST_TYPES)
}

tt_indexes = {
   val : i for i, val in enumerate(TEST_TYPES)
}

# Global variables

tests_by_type : Dict[str, List[str]] = { k: [] for k in TEST_TYPES }
tests_to_run  : Dict[str, int]       = { k:  0 for k in TEST_TYPES }
tests_passed  : Dict[str, int]       = { k:  0 for k in TEST_TYPES }

def load_all_tests():

   global tests_by_type

   for tt in TEST_TYPES:
      tests_by_type[tt] = globals()[load_tests_func_by_type[tt]]()

def load_list_of_shell_cmd_tests():

   result = []

   tt_short = SHORT_TEST_TIMEOUT
   tt_med = MED_TEST_TIMEOUT
   tt_long = LONG_TEST_TIMEOUT

   devshell = os.path.join(BUILD_DIR, 'userapps', 'devshell')
   output = subprocess.check_output([devshell, '-l']).decode("utf-8")
   arr = output.split("\n")

   for r in arr:

      r = r.rstrip()

      if not r:
         continue

      name, tt = r.split(' ')
      tt = locals()[tt]
      result.append([name, tt])

   return sorted(result, key = lambda x: x[1])

def load_list_of_kernel_self_tests():

   result = []
   rows = subprocess                             \
            .check_output(['nm', KERNEL_FILE])   \
               .decode("utf-8")                  \
                  .split("\n")

   t_short = SHORT_TEST_TIMEOUT
   t_med = MED_TEST_TIMEOUT
   t_long = LONG_TEST_TIMEOUT
   t_manual = MANUAL_TEST_TIMEOUT

   for row in rows:

      row = row.rstrip()

      if not row:
         continue

      vaddr, t, name = row.split(' ')

      if not name.startswith('selftest_'):
         continue

      comps = name.split('_')
      tt = comps[-1]

      if tt not in ['short', 'med', 'long', 'manual']:
         continue

      name = '_'.join(comps[1:])
      tt = locals()["t_" + tt]
      result.append([name, tt])

   return sorted(result, key = lambda x: x[1])


def internal_single_test_runner_thread(test_type, test, timeout, show_output):

   raw_print(
      "[ RUNNING ] {}: '{}' [timeout: {}]".format(test_type, test, timeout)
   )

   start_time = time.time()

   p = subprocess.Popen(
      [
         '@CMAKE_BINARY_DIR@/st/single_test_run',
         test_type,
         test,
         str(timeout),
         get_qemu_kvm_version()
      ],
      stdin=subprocess.DEVNULL,
      stdout=subprocess.PIPE,
      stderr=subprocess.STDOUT,
   )

   if show_output:
     raw_print("")

   bin_output = b''

   while p.poll() is None:

      bintext = p.stdout.read()

      if not bintext:
         time.sleep(0.1)
         continue

      if show_output:
         direct_print(bintext)
      else:
         bin_output += bintext

   elapsed = time.time() - start_time

   if p.returncode != 0:

      if not show_output:
         raw_print("")
         direct_print(bin_output)

      raw_print(
         "[ FAILED  ] after {:.2f} seconds with: {}\n"
            .format(elapsed, get_fail_by_code(p.returncode))
      )
      return False

   raw_print("[ PASSED  ] after {:.2f} seconds\n".format(elapsed))
   return True

def internal_run_test(test_type, test, timeout, show_output = False):

   with ft.ThreadPoolExecutor(max_workers = 1) as executor:

      future = executor.submit(
         internal_single_test_runner_thread,
         test_type,
         test,
         timeout,
         show_output
      )

      return future.result()

def list_tests(reg_filter, max_timeout, test_type):

   col_names = [['test name', 30], ['test type', 12], ['timeout', 10]]
   raw_stdout_write("\n")

   for x in col_names:
      raw_stdout_write('+-')
      raw_stdout_write(''.center(x[1], '-'))
   raw_stdout_write('+\n')

   for x in col_names:
      raw_stdout_write('| ')
      raw_stdout_write(x[0].center(x[1], ' '))
   raw_stdout_write('|\n')

   for x in col_names:
      raw_stdout_write('+-')
      raw_stdout_write(''.center(x[1], '-'))
   raw_stdout_write('+\n')

   for tt in TEST_TYPES:

      count = 0

      if test_type and tt != test_type:
         continue

      for x in tests_by_type[tt]:

         name = x[0]
         timeout = x[1]
         ts = str(timeout) if timeout != MANUAL_TEST_TIMEOUT else "<manual>"

         if timeout <= max_timeout and re.match(reg_filter, name):
            raw_stdout_write('| ')
            raw_stdout_write(name.ljust(col_names[0][1]))
            raw_stdout_write('| ')
            raw_stdout_write(tt.ljust(col_names[1][1]))
            raw_stdout_write('| ')
            raw_stdout_write(ts.ljust(col_names[2][1]))
            raw_stdout_write('|\n')
            count += 1

      if count > 0:
         for x in col_names:
            raw_stdout_write('+-')
            raw_stdout_write(''.center(x[1], '-'))
         raw_stdout_write('+\n')

   raw_stdout_write('\n')

def get_sum(per_test_counter):
   return sum(per_test_counter[k] for k in per_test_counter)

def run_test(test_type, x, show_output):

   global tests_to_run, tests_passed

   if get_sum(tests_to_run) == 0:
      raw_print("")

   tests_to_run[test_type] += 1
   if internal_run_test(test_type, x[0], x[1], show_output):
      tests_passed[test_type] += 1

def run_all_tests(max_test_timeout, show_output, reg, fail_on_zero, test_type):

   for tt in TEST_TYPES:

      if test_type and tt != test_type:
         continue

      for x in tests_by_type[tt]:
         if re.match(reg, x[0]) and x[1] <= max_test_timeout:
            if x[1] != MANUAL_TEST_TIMEOUT:
               run_test(tt, x, show_output)

   if fail_on_zero:
      if tests_to_run['selftest'] + tests_to_run['shellcmd'] == 0:

         found = []
         for tt in TEST_TYPES:
            for x in tests_by_type[tt]:
               if re.match(reg, x[0]):
                  found.append(x)

         if not found:
            raw_print("ERROR: No tests matching the '{}' regex.".format(reg))
         else:
            raw_print(
               "ERROR: No tests matching "
               "the '{}' regex having timeout <= {}"
                  .format(reg, max_test_timeout)
            )
            raw_print(
               "Tests matching the regex with timeout > {}:"
                  .format(max_test_timeout)
            )
            for x in found:
               if x[1] != MANUAL_TEST_TIMEOUT:
                  raw_print("  {} [timeout: {}s]".format(x[0].ljust(20), x[1]))
               else:
                  raw_print("  {} [manual test]".format(x[0].ljust(20)))

         sys.exit(Fail.no_tests_matching.value)

def dump_test_stats():

   raw_print('-' * 80)

   for tt in TEST_TYPES:
      if tests_to_run[tt]:
         raw_print("{} passed: {}/{}"
                     .format(tt_pretty_names[tt],
                             tests_passed[tt],
                             tests_to_run[tt]))

def parse_args():

   parser = argparse.ArgumentParser()

   g = parser.add_mutually_exclusive_group()

   g.add_argument(
      "-l", "--list-tests",
      action = "store_true",
      help = "list all tests matching the criteria (dry-run)"
   )

   g.add_argument(
      "-L", "--list-all-tests",
      action = "store_true",
      help = "list ALL tests"
   )

   parser.add_argument(
      "-c", "--compact-run",
      action = "store_true",
      help = "run all the shellcmds in a single VM run (faster)"
   )

   parser.add_argument(
      "-o", "--show-output",
      action = "store_true",
      help = "always show test's output"
   )

   parser.add_argument(
      "-r", "--regex_filter",
      type = str,
      default = ".*",
      help = "run only the tests matching the given regex"
   )

   parser.add_argument(
      "-t", "--max-timeout",
      type = int,
      default = MED_TEST_TIMEOUT,
      help = "run only the tests having timeout <= MAX_TIMEOUT"
   )

   parser.add_argument(
      "-T", "--test_type",
      type = str,
      choices = TEST_TYPES,
      help = "run only tests of the given type"
   )

   try:
      args = parser.parse_args()
   except SystemExit:
      sys.exit(Fail.invalid_args.value)

   return args

def main():

   global tests_by_type
   global tests_to_run
   set_runner_name("test runner")

   load_all_tests()
   args = parse_args()

   if args.list_all_tests:
      args.max_timeout = MANUAL_TEST_TIMEOUT
      args.regex_filter = ".*"
      args.list_tests = True

   if args.max_timeout == 0:
      args.max_timeout = MANUAL_TEST_TIMEOUT

   if args.list_tests:
      list_tests(args.regex_filter, args.max_timeout, args.test_type)
      sys.exit(0)

   if args.compact_run:
      tests_by_type['shellcmd'] = []

   detect_kvm()

   if is_cmake_opt_enabled(KERNEL_FORCE_TC_ISYSTEM):
      unrunnable_build_graceful_exit()

   try:

      run_all_tests(args.max_timeout,
                    args.show_output,
                    args.regex_filter,
                    not args.compact_run,
                    args.test_type)

      if args.compact_run:
         if not args.test_type or args.test_type == 'shellcmd':
            run_test('shellcmd',
                     ['runall', MED_TEST_TIMEOUT * 4],
                     args.show_output)

   except KeyboardInterrupt:
      msg_print("KeyboardInterrupt")
      sys.exit(Fail.user_interruption.value)

   dump_test_stats()

   if get_sum(tests_passed) != get_sum(tests_to_run):
      sys.exit(Fail.some_tests_failed.value)

###############################
if __name__ == '__main__':
   main()
