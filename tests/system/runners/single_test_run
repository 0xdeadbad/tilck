#!/usr/bin/python3
# SPDX-License-Identifier: BSD-2-Clause

import os
import re
import sys
import time
import signal
import subprocess
import threading
import struct
import zlib
import base64
import fcntl

# Local imports
from utils import * # pylint: disable=unused-wildcard-import

# Other constants
INIT_PATH = '/initrd/bin/init'
DEVSHELL_PATH = '/initrd/usr/bin/devshell'
KERNEL_HELLO_MSG = 'Hello from Tilck!'
KERNEL_DUMP_GCDA_STR = '** GCOV gcda files **'
FATPART_FILE = '@CMAKE_BINARY_DIR@/fatpart'
GEN_KCOV_REPORT = '@CMAKE_BINARY_DIR@/scripts/generate_kernel_coverage_report'

# Environment config variables
VM_MEMORY_SIZE_IN_MB = int(os.environ.get('TILCK_VM_MEM', '128'))

# Environment flags
in_travis = os.environ.get('TRAVIS', False)
in_circleci = os.environ.get('CIRCLECI', False)
dump_coverage = os.environ.get('DUMP_COV', False)
report_coverage = os.environ.get('REPORT_COV', False)
verbose = os.environ.get('VERBOSE', False)

# Global variables

# Controlled by command line
g_test_name = None
g_test_type = None
g_test_timeout = None

# Internal state
output = ""
process = None
fail_reason = Fail.success
hello_msg_found = False
shell_exit_code = -1
dumping_gcda_files = False
gcda_buf = None
gcda_file = None
notBase64Char = re.compile(r'[^A-Za-z0-9+/=]')

def set_fail_reason(reason: Fail):
   global fail_reason
   assert(fail_reason == Fail.success)
   fail_reason = reason

def append_to_output(s: str):
   global output
   output += s

def set_qemu_process(p):
   global process
   assert(process is None)
   process = p

def write_gcda_file():

   global gcda_file, gcda_buf, process

   try:

      orig_gcda_buf = gcda_buf
      gcda_buf = base64.b64decode(gcda_buf)
      gcda_buf = zlib.decompress(gcda_buf)

      with open(gcda_file, 'wb') as fh:
         fh.write(gcda_buf)

   except Exception as e:
      set_fail_reason(Fail.gcov_error)
      msg_print("")
      msg_print(
         "While working on gcda file '{}', "
         "got exception: {}".format(gcda_file, str(e))
      )
      raw_print("gcda_buf:\n<<{}>>\n".format(orig_gcda_buf))
      process.send_signal(signal.SIGINT)

   finally:
      gcda_file = None
      gcda_buf = None

def handle_hello_msg(line: str):

   global hello_msg_found

   if not hello_msg_found:
      hello_msg_found = True
      raw_print(line)
      return

   # Bad case
   msg_print("")
   msg_print("Detected TWICE the kernel hello msg: the machine rebooted.")
   msg_print("KILLING the VM.")

   set_fail_reason(Fail.reboot)
   process.send_signal(signal.SIGINT)

def process_line(line: str):

   global shell_exit_code
   global dumping_gcda_files
   global gcda_buf
   global gcda_file

   stripped = line.rstrip()
   #raw_print(stripped)

   if stripped and stripped[0] == '[' and stripped.startswith('[init]'):
      m = re.search(r'the devshell exited with status: ([0-9]+)', stripped)

      if m:
         shell_exit_code = int(m.group(1))
         dumping_gcda_files = False
         raw_print(stripped)
         return

   if stripped.find(KERNEL_HELLO_MSG) != -1:
      handle_hello_msg(stripped)
      return

   # NOTE: we could kill the VM immediately after a kernel panic, but we'll
   # loose the backtrace. TODO: detect kernel panic here, but kill the VM after
   # a some timeout (e.g. 1 sec).
   #
   # if stripped.find("KERNEL PANIC") != -1:
   #    raw_print("[system test runner] Detected kernel panic: KILLING the VM.")
   #    set_fail_reason(Fail.panic)
   #    process.send_signal(signal.SIGINT)

   if not dumping_gcda_files:

      append_to_output(stripped + "\n")
      raw_print(stripped)

      if stripped.find(KERNEL_DUMP_GCDA_STR) != -1:
         dumping_gcda_files = True

      return

   # Dumping gcda file

   if not stripped:
      return

   if notBase64Char.search(stripped[0]):

      if gcda_file:
         write_gcda_file()

      dumping_gcda_files = False
      raw_print(stripped)
      return

   m = re.search(r'file: (.+)', stripped)

   if m:

      if gcda_file:
         write_gcda_file()

      gcda_file = m.group(1)
      gcda_buf = ''

   else:
      gcda_buf += stripped

def process_text(text: str):

   # python's split always leaves an empty element in case of a trailing
   # delimiter. For example:
   #
   #     "a,b,c,".split(",")
   #
   # produces
   #
   #     ["a", "b", "c", ""]
   #
   # Therefore, it's always OK to discard the last line and return it, to
   # be used for the next (which will be appended to it).

   lines = text.split("\n")

   for ln in lines[:-1]:
      process_line(ln)

   return lines[-1]

def run_the_vm():

   global shell_exit_code
   global dumping_gcda_files
   global gcda_buf
   global gcda_file

   args = ['qemu-system-i386',
           '-m', str(VM_MEMORY_SIZE_IN_MB),
           '-kernel', KERNEL_FILE,
           '-nographic', '-device',
           'isa-debug-exit,iobase=0xf4,iosize=0x04']

   if not in_travis and not in_circleci:
      args.append('-enable-kvm')

   kernel_cmdline = '-sercon '
   cmdline = DEVSHELL_PATH
   init_opts = '-ns'

   if dump_coverage:
      cmdline += ' -dcov'
      init_opts += ' -q'

   if in_circleci:
      kernel_cmdline += ' -sat' # enable sched alive (debug) thread

   if g_test_type == 'shellcmd':

      raw_print("Running the VM with shell command '{}'...".format(g_test_name))
      cmdline += ' -c ' + g_test_name

   elif g_test_type == 'selftest':

      raw_print("Running the VM with selftest '{}'...".format(g_test_name))
      cmdline += ' -c selftest ' + g_test_name

   else:
      sys.exit(1)

   kernel_cmdline += ' -cmd {} {} -- {}'.format(INIT_PATH, init_opts, cmdline)
   args += ['-initrd', FATPART_FILE, '-append', kernel_cmdline]

   if verbose:
      raw_print(" ".join(args))

   raw_print('-' * 80)
   raw_print("")

   # Run the QEMU process by using a PIPE for its stdout
   process = subprocess.Popen(args, stdout=subprocess.PIPE)
   set_qemu_process(process)

   # Get the current flags for the `stdout` file descriptor
   fl = fcntl.fcntl(process.stdout.fileno(), fcntl.F_GETFL)

   # Make the `stdout` file descriptor non-blocking
   fcntl.fcntl(process.stdout.fileno(), fcntl.F_SETFL, fl | os.O_NONBLOCK)

   read_anything = False
   start_time = time.time()
   incomplete_line = ''

   while True:

      text = process.stdout.read()

      # In python 3, read() will return None when there's nothing to read on
      # a non-blocking stream. On python 2 instead, it used to throw an IOError
      # and return None only in case of EOF. Now, apprently, there's no way to
      # detect the EOF case. Therefore, process.poll() is used. It returns
      # process' exit-code if the process terminated, otherwise None.
      if not text:

         if process.poll() is not None:

            if incomplete_line:
               process_line(incomplete_line)

            break # The process exited, we have to stop reading

         if not read_anything:
            time.sleep(0.1)
            continue

         curr_time = time.time()
         e = curr_time - start_time

         if e >= 1.0:
            msg_print("WARNING: got nothing in {:.2f} sec".format(e))
            start_time = curr_time

         time.sleep(0.1)
         continue

      if not read_anything:
         elapsed = time.time() - start_time
         read_anything = True
         msg_print("First output after {:.2f} s".format(elapsed))

      start_time = time.time()
      text = incomplete_line + text.decode('latin-1')
      incomplete_line = process_text(text)

   raw_print('-' * 80)

def show_help_and_exit():
   raw_print("Syntax: ")
   raw_print("  single_test_run selftest <name> <timeout>")
   raw_print("  single_test_run shellcmd <name> <timeout>")
   sys.exit(1)

###############################################################################
# MAIN

if len(sys.argv) < 4:
   show_help_and_exit()

if sys.argv[1] not in ['selftest', 'shellcmd']:
   show_help_and_exit()

g_test_type = sys.argv[1]
g_test_name = sys.argv[2]
g_test_timeout = int(sys.argv[3])

thread = threading.Thread(target = run_the_vm)
thread.start()
thread.join(g_test_timeout)

if thread.is_alive():

   if dumping_gcda_files:
      thread.join(30)

   if thread.is_alive():
      set_fail_reason(Fail.timeout)

      msg_print(
         "The VM is alive after the timeout "
         "of {} seconds. KILLING IT.".format(g_test_timeout)
      )

      process.send_signal(signal.SIGINT)
      thread.join()

if gcda_file:
   write_gcda_file()

if output.find("KERNEL PANIC") != -1:
   set_fail_reason(Fail.panic)

if fail_reason == Fail.success and shell_exit_code != 0:
   msg_print("Shell exited with code {}.".format(shell_exit_code))
   set_fail_reason(Fail.shell_no_zero_exit)

if fail_reason == Fail.success and dump_coverage and report_coverage:

   try:

      subprocess.check_output([GEN_KCOV_REPORT, '--acc'])

   except Exception as e:

      msg_print(
         "{} generated the exception: {}".format(GEN_KCOV_REPORT, str(e))
      )
      msg_print("Output of {} --acc:".format(GEN_KCOV_REPORT))
      raw_print(getattr(e, 'output', '<no output>'))
      msg_print("--- end output ---")
      sys.exit(Fail.gcov_error)

sys.exit(fail_reason.value)

